# 0.2 Revisões (HASKELL)

Aqui serão feitas revisões dos conteúdos da UC "Programação Funcional" que serão úteis para a UC de "Cálculo de Programas".

### Haskell na Indústria
https://wiki.haskell.org/Haskell_in_industry

-----------------------------------------------------------------
### Manipular Listas / _Arrays_
```haskell
1:2:3:[] = 1:2:[3] = 1:[2,3] = [1,2,3]
```
-----------------------------------------------------------------
### Recursividade (exemplo de função)
```haskell
sum [ ] = 0
sum (h : t) = h + sum t
```
-----------------------------------------------------------------

### Tipos de dados pré-definidos em Haskell (consultar _ghci_ para mais informações)
```haskell
data Bool = True | False
data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) 
data Maybe a = Nothing | Just a
```
-----------------------------------------------------------------

### Funções pré-definidas em Haskell
```haskell
zip :: [a] -> [b] -> [(a,b)]    -- ex:  zip [1,2,3,4,5] []

split :: (a -> b) -> (a -> c) -> a -> (b,c)
split f g x = (f x, g x)

-- Funções Ficha 1
uncurry :: (a → b → c) → (a, b) → c    -- emparelha os argumentos de uma função

curry :: ((a, b) → c) → a → b → c    -- faz o efeito inverso da anterior)
curry f a b = f (a, b)

flip :: (a → b → c) → b → a → c    -- troca a ordem dos argumentos de uma função
```

-----------------------------------------------------------------

### BTree - Pesquisa Binária

```haskell
data LTree a = Leaf a | Fork (LTree a, LTree a) deriving (Show, Eq)

data BTree = Empty | Node (A,(BTree, BTree))

lookBTree :: Ord a => a -> BTree (a,b) -> Maybe a
lookBTree a Empty = Nothing
lookBTree a (Node((a',b'),(l,r)))
    | a == a' = Just b'
    | a < a' = lookBTree a l
    | a > a' = lookBTree a r
```

------------------------------------------------------------------
### Monade IO (Input/Output)

```haskell
main :: IO ()
main = putStrLn "Test suite not yet implemented"
```

-------------------------------------------------------------------

### Como criar funções _fold_

foldr -> _fold_ + "right" (o elemento seguinte fica à direita da função _f_)
```haskell
foldr :: (a → b → b) → b → [a] → b
foldr f z [ ] = z
foldr f z (h : t) = f h (foldr f z t)
```

Usando o foldr podemos agora redefinir funções (antes recursivas) sem mencionar explicitamente a invocação recursiva.

```haskell
sum :: [Int] → Int
sum [ ] = 0
sum (h : t) = h + sum t

-- transforma-se em:
sum [ ] = 0
sum (h : t) = (λx y → x + y) h (sum t)

-- com foldr:
sum = foldr (+) 0
```

------------------------------------------------------------------



------------------------------------------------------------------

### Curiosidade - "Recursividade Recursiva - Recursive Recursion"
#### fonte: @acmota2 (https://www.instagram.com/p/Cgu8H4JhZQK/)
```haskell
recursiveRecursion a
    | null a = a
    | otherwise = recursiveRecursion (other a)
```

------------------------------------------------------------------

### Bibliografia

- _Category Theory for Programmers_: https://unglueit-files.s3.amazonaws.com/ebf/e90890f0a6ea420c9825657d6f3a851d.pdf
